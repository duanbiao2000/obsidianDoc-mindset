好的，這篇筆記 [[三日份加强]] 深入探討了 React 中兩個核心且實用的主題：**請求緩存策略** 和 **使用 `useContext` + `useReducer` 進行複雜狀態管理**。以下是對這兩部分內容的梳理和總結。

### 一、React 中的請求緩存策略

筆記指出，React 本身不負責請求緩存，這是一個架構決策。開發者可以根據項目需求選擇不同的實現方式。

| 方式 (Approach) | 核心思想 (Core Idea) | 優點 (Pros) | 缺點 (Cons) |
| :--- | :--- | :--- | :--- |
| **1. 數據獲取層處理** | 在 `axios` 或 `fetch` 的基礎上包裝一層緩存邏輯，例如使用 `Map` 存儲請求結果和時間戳。 | 與 React 解耦，復用性強，適用於任何框架。 | 需要手動維護緩存邏輯，如過期清理。 |
| **2. 狀態管理庫接管** | 將緩存數據作為全局狀態的一部分，存儲在 Redux、Zustand 等庫的 store 中。 | 適合全局狀態管理，緩存邏輯與業務邏輯集中，維護方便。 | 對於簡單項目可能過於笨重。 |
| **3. 使用專用庫 (推薦)** | 使用 `React Query` (TanStack Query) 或 `SWR` 這些專為數據獲取和緩存設計的庫。 | 專業、高效，內置緩存、自動重試、失效時間管理等高級功能，極大簡化開發。 | 有一定的學習成本。 |
| **4. 組件層自己搞 (不推薦)** | 在組件內部使用 `useState` 或 `useMemo` 存儲請求結果。 | 基本無，只適用於極其臨時的 hack。 | 邏輯分散，復用性差，組件卸載後緩存丟失，維護成本極高。 |

#### 核心建議

*   **小項目**: 在 `axios/fetch` 層實現簡單緩存即可。
*   **中大型項目**: 強烈推薦使用 **React Query** 或 **SWR**，讓專業工具做專業的事。
*   **全局狀態複雜**: 若項目已深度使用狀態管理庫，可將緩存邏輯整合進去。
*   **避免在組件層硬搞**，這會導致後續維護困難。

---

### 二、使用 `useContext` + `useReducer` 管理複雜狀態

這個組合非常適合處理具有複雜更新邏輯的狀態，例如任務管理應用。`useContext` 負責將狀態和操作（`dispatch`）廣播給後代組件，而 `useReducer` 則集中管理狀態的更新邏輯。

#### 實現步驟

1.  **創建 `reducer`**: 編寫一個純函數，根據傳入的 `action`（如 `ADD_TASK`, `DELETE_TASK`）來返回新的 `state`。
2.  **創建 `Context` 和 `Provider`**: 在 `Provider` 組件中使用 `useReducer` 鉤子來管理狀態，並將 `state` 和 `dispatch` 函數通過 `Context.Provider` 的 `value` 傳遞下去。
3.  **包裹應用**: 在應用的頂層或需要共享狀態的組件樹根部，使用 `Provider` 進行包裹。
4.  **在組件中使用**: 子組件通過 `useContext` 鉤子獲取 `state` 和 `dispatch`，使用 `state` 來渲染UI，調用 `dispatch` 來觸發狀態更新。

#### 性能優化與踩坑經驗

*   **性能問題**: `Context` 的一個主要問題是，只要 `value` 發生變化，所有消費該 `Context` 的組件都會重新渲染。
*   **優化方案**:
    1.  **穩定 `value` 對象**: 使用 `useMemo` 來包裹 `Provider` 的 `value` 對象，確保只有在 `state` 真正改變時才創建新對象。
    2.  **拆分 `Context`**: 將一個大的 `Context` 拆分成多個更細粒度的 `Context`。例如，將任務列表和任務統計數據分開，這樣只關心統計數據的組件就不會因為任務列表的變化而重渲染。
*   **踩坑經驗**:
    *   **Reducer 邏輯不宜過於複雜**: 複雜的計算（如過濾、排序）應放在組件的 `useMemo` 中，Reducer 只負責核心的狀態更新。
    *   **Action 命名要清晰**: 使用明確的 `action.type`（如 `TOGGLE_TASK` 而非 `TOGGLE`）以提高可讀性和可維護性。
    *   **異步處理**: `useReducer` 本身不直接支持異步操作。處理異步請求建議結合 `useEffect` 或使用 React Query 等專用庫。
    *   **控制 `Provider` 範圍**: 只在需要共享狀態的組件樹部分使用 `Provider`，避免不必要的全局包裹。